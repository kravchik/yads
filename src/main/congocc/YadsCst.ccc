// CongoCC grammar (adapted from JavaCC version)

PARSER_PACKAGE = yk.lang.yads.congocc;
NODE_PACKAGE = yk.lang.yads.congocc.nodes;
JAVA_UNICODE_ESCAPE = true;
TREE_BUILDING_ENABLED = false;

INJECT YadsCstLexer : {
    public YadsCstLexer(String inputSource, CharSequence input, LexicalState lexState, int startingLine, int startingColumn, boolean preserveLineEndings) {
        super(inputSource, input, startingLine, startingColumn, 1, true, preserveLineEndings, true, "");
        if (lexicalState != null) switchTo(lexState);
    }
}

INJECT YadsCstParser : {
    import yk.ycollections.YList;
    import static yk.ycollections.YArrayList.al;
    import static yk.ycollections.YHashMap.hm;
    import yk.lang.yads.utils.Caret;
    import yk.lang.yads.YadsCst;
    import yk.ycollections.YMap;
    import yk.lang.yads.utils.YadsUtils;
}

INJECT YadsCstParser :
{
    /**
     * Convenient static method to parse a string directly
     * @param s the string to parse
     * @return the parsed YadsCst
     */
    public static YadsCst parse(String s) {
        //NOTE ! Should use special constructor with preserveLineEndings == true to properly handle \r
        //  (we are getting rid of \r instead of converting it to \n)
        YadsCstParser parser = new YadsCstParser(new YadsCstLexer("input", s, YadsCstLexer.LexicalState.DEFAULT, 1, 1, true));
        return parser.parseListBody();
    }

    private YList<Caret> caretStack = al();
    
    private void beginCaret() {
        // Create caret with current token position
        Token currentToken = getToken(0);
        if (currentToken.getType() != Token.TokenType.DUMMY) {
            Caret caret = new Caret(
                currentToken.getBeginLine(), currentToken.getBeginColumn(),
                0, 0, // End will be set later
                currentToken.getBeginOffset(), -1 // End offset will be set later
            );
            caretStack.add(caret);
        } else {
            // create default caret for empty input
            Caret caret = new Caret(1, 1, 0, 0, 0, -1);
            caretStack.add(caret);
        }
    }
    
    private Caret finishCaret() {
        if (caretStack.isEmpty()) return null;
        Caret caret = caretStack.remove(caretStack.size() - 1);
        Token currentToken = getToken(0);
        if (currentToken != null && currentToken.getType() != Token.TokenType.DUMMY && currentToken.getType() != Token.TokenType.EOF) {
            caret.endLine = currentToken.getEndLine();
            caret.endColumn = currentToken.getEndColumn();
            caret.endOffset = currentToken.getEndOffset();
        } else {
            // DUMMY, EOF, or no token - set end same as begin
            caret.endLine = caret.beginLine;
            caret.endColumn = caret.beginColumn;
            caret.endOffset = caret.beginOffset;
        }
        return caret;
    }
    
    // Helper method to create Caret from Token without direct dependency
    private Caret createCaret(Token token) {
        return new Caret(
            token.getBeginLine(), token.getBeginColumn(),
            token.getEndLine(), token.getEndColumn(),
            token.getBeginOffset(), token.getEndOffset()
        );
    }
}


// Whitespace tokens
TOKEN : <WHITE_SPACE : (" " | "\t" | "\n" | "\r" | "\f")+> ;

// Structural tokens
TOKEN :
    <LEFT_PAREN: "(">
  | <RIGHT_PAREN: ")">
  | <COMMENT_SINGLE_LINE: "//" (~["\n","\r"])*>
  | <COMMENT_MULTI_LINE: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
  | <INTEGER_LITERAL: ("-")?(<DECIMAL_LITERAL> | <HEX_LITERAL> | <OCTAL_LITERAL>)(["l","L"])?>
  | <#DECIMAL_LITERAL: ("-")?(["1"-"9"] (["0"-"9"])*)>
  | <#HEX_LITERAL: ("-")?("0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+)>
  | <#OCTAL_LITERAL: ("-")?("0" (["0"-"7"])*)>
  | <FLOATING_POINT_LITERAL: ("-")?(
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
)>
  | <#EXPONENT: ("-")?(["e","E"] (["+","-"])? (["0"-"9"])+)>
  | <ANY_LITERAL: (["a"-"z","A"-"Z","0"-"9",".","_","$"])+>
  | <ANY_OPERATOR: ((["+","-","/", "*","%","!","=","^","&","|", "<", ">", "?"])+)>
  | <ANY_SEPARATOR: (([",",";"]))>
  | <STRING_LITERAL_DQ: "\""
      (   (~["\"","\\"])
        | ("\\" ~[])
      )*
      "\"">
  | <STRING_LITERAL_SQ: "'"
      (   (~["'","\\"])
        | ("\\" ~[])
      )*
      "'">
//  | <STRING_LITERAL_DQ: "\"" ( ~["\""] | "\"\"" )* "\"" >
//  | <STRING_LITERAL_SQ: "'" ( ~["'"] | "''" )* "'" >
;


// Main API method - parses list body (sequence of elements)
YadsCst parseListBody() #void :
{
    YList<YadsCst> list;
    beginCaret();
}
    list = parseList()
    {
      return new YadsCst("LIST_BODY", finishCaret(), list);
    }
;

YList parseList() #void :
{
    YList<YadsCst> list = al();
    YadsCst value;
}
    {beginCaret();}
    [ <WHITE_SPACE> ]
    [
      value = parseElement() { list.add(value); }
      [ <WHITE_SPACE> ]
      (
        value = parseElement() { list.add(value); }
        [ <WHITE_SPACE> ]
      )*
    ]
    { return list; }
;

// Helper method - parses any element (literal, class, comment, etc.)
YadsCst parseElement() #void :
{
    Token t;
    YadsCst node;
}

    node = parseIdentifierOrClass() { return node; }
  |
    node = parseUnnamedClass(null) { return node; }
  |
    t = <COMMENT_SINGLE_LINE> { return new YadsCst("COMMENT_SINGLE_LINE", createCaret(t), t.toString()); }
  |
    t = <COMMENT_MULTI_LINE> { return new YadsCst("COMMENT_MULTI_LINE", createCaret(t), t.toString()); }
  |
    t = <INTEGER_LITERAL> { 
        String tokenStr = t.toString();
        String lowerStr = tokenStr.toLowerCase();
        Object value;
        if (lowerStr.endsWith("l")) {
            value = Long.parseLong(tokenStr.substring(0, tokenStr.length() - 1));
        } else {
            value = Integer.parseInt(tokenStr);
        }
        return new YadsCst("INTEGER_LITERAL", createCaret(t), value);
    }
  |
    t = <FLOATING_POINT_LITERAL> { 
        String tokenStr = t.toString();
        String lowerStr = tokenStr.toLowerCase();
        Object value;
        if (lowerStr.endsWith("d")) {
            value = Double.parseDouble(tokenStr.substring(0, tokenStr.length() - 1));
        } else if (lowerStr.endsWith("f")) {
            value = Float.parseFloat(tokenStr.substring(0, tokenStr.length() - 1));
        } else {
            value = Float.parseFloat(tokenStr);
        }
        return new YadsCst("FLOATING_POINT_LITERAL", createCaret(t), value);
    }
  |
    t = <ANY_OPERATOR> { 
        return new YadsCst("ANY_OPERATOR", createCaret(t), t.toString()); 
    }
  |
    t = <ANY_SEPARATOR> {
        return new YadsCst("ANY_SEPARATOR", createCaret(t), t.toString());
    }
  |
    t = <STRING_LITERAL_DQ> {
        return new YadsCst("STRING_LITERAL_DQ", createCaret(t), 
            YadsUtils.unescapeDoubleQuotes(t.toString())); 
    }
  |
    t = <STRING_LITERAL_SQ> { 
        return new YadsCst("STRING_LITERAL_SQ", createCaret(t), 
            YadsUtils.unescapeSingleQuotes(t.toString())); 
    }
;

// Helper method - parses identifier and decides if it's a standalone literal or part of named class
YadsCst parseIdentifierOrClass() #void :
{
    Token identifier;
    YadsCst nameNode;
}
    identifier = <ANY_LITERAL> {
        String identifierStr = identifier.toString();
        Object value;
        if ("true".equals(identifierStr)) {
            value = Boolean.TRUE;
        } else if ("false".equals(identifierStr)) {
            value = Boolean.FALSE;
        } else if ("null".equals(identifierStr)) {
            value = null;
        } else {
            value = identifierStr;
        }
        nameNode = new YadsCst("ANY_LITERAL", createCaret(identifier), value);
    }
    [
        nameNode = parseUnnamedClass(nameNode)
    ]
    {
        return nameNode;
    }
;

// Helper method - parses left parenthesis and returns node
YadsCst parseLeftParen() #void :
{
    Token leftParen;
}
    leftParen = <LEFT_PAREN> {
        return new YadsCst("LEFT_PAREN", createCaret(leftParen));
    }
;

// Helper method - parses right parenthesis and returns node
YadsCst parseRightParen() #void :
{
    Token rightParen;
}
    rightParen = <RIGHT_PAREN> {
        return new YadsCst("RIGHT_PAREN", createCaret(rightParen));
    }
;

// Helper method - parses class starting with '(' (optionally with name)
YadsCst parseUnnamedClass(YadsCst nameNode) #void :
{
    YadsCst leftParenNode;
    YadsCst rightParenNode;
    YadsCst body;
    YList<YadsCst> children = al();
    YMap<String, YadsCst> fields = hm();
    if (nameNode != null) {
        fields.put("name", nameNode);
        children.add(nameNode);
    }
}
    leftParenNode = parseLeftParen() { children.add(leftParenNode); }
    body = parseListBody() { children.add(body); }
    rightParenNode = parseRightParen() {
        children.add(rightParenNode);
        fields.put("body", body);
        if (nameNode != null) {
            return new YadsCst("NAMED_CLASS", Caret.startEnd(nameNode.caret, rightParenNode.caret), null, children, fields);
        } else {
            return new YadsCst("UNNAMED_CLASS", Caret.startEnd(leftParenNode.caret, rightParenNode.caret), null, children, fields);
        }
    }
;

// Main API method - parses either named or unnamed class
YadsCst parseClass() #void :
{
    YadsCst node;
}
    node = parseIdentifierOrClass() { 
        if ("NAMED_CLASS".equals(node.type)) {
            return node;
        } else {
            throw new ParseException("Expected a class, but got: " + node.type);
        }
    }
  |
    node = parseUnnamedClass(null) { return node; }
;
